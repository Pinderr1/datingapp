// Firestore Security Rules â€” Pinged MVP (aligned with app writes + lastMessage)
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function isSignedIn() { return request.auth != null; }
    function isOwner(uid) { return isSignedIn() && request.auth.uid == uid; }

    // Safe: returns [] if match missing
    function matchUsers(matchId) {
      let m = get(/databases/$(database)/documents/matches/$(matchId));
      return m.data != null && m.data.users != null ? m.data.users : [];
    }

    // ---------- Validators ----------
    function isValidString(s, min, max) {
      return s is string && s.size() >= min && s.size() <= max;
    }
    function isOptionalString(data, key, min, max) {
      return (!data.keys().hasAny([key])) || isValidString(data[key], min, max);
    }
    function isOptionalTimestamp(data, key) {
      return (!data.keys().hasAny([key])) || (data[key] is timestamp);
    }
    function isOptionalUrlList(data, key) {
      return (!data.keys().hasAny([key])) ||
             (data[key] is list && data[key].all(u, u is string && u.size() > 0 && u.size() <= 2048));
    }
    function isOptionalNumberInRange(data, key, min, max) {
      return (!data.keys().hasAny([key])) ||
             ((data[key] is int || data[key] is float) &&
              data[key] >= min &&
              data[key] <= max);
    }

    // Allow only the user profile fields we actually use.
    function isValidUserData(data) {
      // Only these keys are allowed on /users/{uid}
      return data.keys().hasOnly([
        'uid',
        'email',
        'displayName',
        'name',
        'photoURL',
        'phoneNumber',
        'providerId',
        'bio',
        'gender',
        'age',
        'photoURLs',
        'createdAt',
        'updatedAt'
      ]) &&

      // Optional but constrained fields
      isOptionalString(data, 'uid', 1, 128) &&
      isOptionalString(data, 'email', 3, 320) &&
      isOptionalString(data, 'displayName', 0, 40) &&
      isOptionalString(data, 'name', 0, 80) &&
      isOptionalString(data, 'photoURL', 0, 2048) &&
      isOptionalString(data, 'phoneNumber', 7, 20) &&
      isOptionalString(data, 'providerId', 0, 100) &&
      isOptionalString(data, 'bio', 0, 300) &&
      isOptionalString(data, 'gender', 0, 40) &&
      isOptionalNumberInRange(data, 'age', 18, 120) &&
      isOptionalUrlList(data, 'photoURLs') &&
      isOptionalTimestamp(data, 'createdAt') &&
      isOptionalTimestamp(data, 'updatedAt');
    }

    function isMatchParticipant(users) {
      return isSignedIn() && users is list && users.hasAny([request.auth.uid]);
    }
    function isValidMatchUsers(users) {
      return users is list &&
             users.size() == 2 &&
             users.all(u, u is string) &&
             users[0] != users[1];
    }

    function isValidMessageData(data) {
      return data.keys().hasOnly(['senderId','content','createdAt']) &&
             data.senderId is string &&
             data.senderId == request.auth.uid &&
             isValidString(data.content, 1, 1000) &&
             isOptionalTimestamp(data, 'createdAt');
    }

    function isValidContactMessage(data) {
      return data.keys().hasOnly(['name','email','message','createdAt']) &&
             isValidString(data.name, 1, 80) &&
             isValidString(data.email, 3, 120) &&
             isValidString(data.message, 1, 2000) &&
             isOptionalTimestamp(data, 'createdAt');
    }

    // ---------- USERS ----------
    match /users/{uid} {
      // Allow a signed-in user to read the directory (for swipe feed)
      allow get, list: if isSignedIn();

      // Owner can create/update only with allowed keys + sane values
      allow create, update: if isOwner(uid) && isValidUserData(request.resource.data);

      allow delete: if isOwner(uid);
    }

    // ---------- LIKES ----------
    match /likes/{uid}/outgoing/{targetId} {
      allow read: if isOwner(uid);
      allow create, update: if isOwner(uid) &&
                            request.auth.uid != targetId &&
                            request.resource.data.keys().hasOnly(['liked','createdAt','updatedAt']) &&
                            (request.resource.data.liked is bool) &&
                            isOptionalTimestamp(request.resource.data, 'createdAt') &&
                            isOptionalTimestamp(request.resource.data, 'updatedAt');
      allow delete: if isOwner(uid);
    }

    // ---------- MATCHES ----------
    match /matches/{matchId} {
      // Only participants can see a match
      allow get, list: if isMatchParticipant(resource.data.users);

      // Create only when reciprocal like exists
      allow create: if isSignedIn() &&
                    // allow optional lastMessage on create
                    request.resource.data.keys().hasOnly(['users','createdAt','updatedAt','lastMessage']) &&
                    isValidMatchUsers(request.resource.data.users) &&
                    request.resource.data.users.hasAny([request.auth.uid]) &&
                    isOptionalString(request.resource.data, 'lastMessage', 0, 1000) &&
                    // Reciprocity check:
                    (let otherUid = request.auth.uid == request.resource.data.users[0]
                                    ? request.resource.data.users[1]
                                    : request.resource.data.users[0];
                     otherUid is string &&
                     otherUid != request.auth.uid &&
                     get(/databases/$(database)/documents/likes/$(otherUid)/outgoing/$(request.auth.uid)).exists());

      // Keep pair immutable; allow timestamp + lastMessage refresh
      allow update: if isMatchParticipant(resource.data.users) &&
                    request.resource.data.keys().hasOnly(['users','createdAt','updatedAt','lastMessage']) &&
                    isValidMatchUsers(request.resource.data.users) &&
                    request.resource.data.users == resource.data.users &&
                    isOptionalString(request.resource.data, 'lastMessage', 0, 1000);

      allow delete: if isMatchParticipant(resource.data.users);

      // ---------- MESSAGES (subcollection) ----------
      match /messages/{msgId} {
        allow get, list: if isMatchParticipant(matchUsers(matchId));
        allow create: if isMatchParticipant(matchUsers(matchId)) &&
                       isValidMessageData(request.resource.data);
      }
    }

    // ---------- CONTACT ----------
    match /contactMessages/{messageId} {
      allow create: if isValidContactMessage(request.resource.data);
    }
  }
}
